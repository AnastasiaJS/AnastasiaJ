<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript中return、break、continue的区别]]></title>
    <url>%2FAnastasiaJ%2F2018%2F09%2F07%2Freturn%E3%80%81break%E3%80%81continue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[break是跳出一层循环，continue是结束一趟循环 ,return才是结束所有层循环! 如果有多层for循环,break会跳出当前这一层,去执行最外层循环(而不是退出所有层循环);而continue则结束当前次循环(继续)而去执行下次循环,但本层循环没有结束.(注意一层循环和一次循环的区别:一层循环包含若干(i)次循环) return return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行。 break 只能在循环体内和switch语句体内使用break语句。 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环。 continue 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PDF.js]]></title>
    <url>%2FAnastasiaJ%2F2018%2F09%2F07%2FPDF-js%2F</url>
    <content type="text"><![CDATA[PDF.js介绍PDF.js 是基于开放的 HTML5 及 JavaScript 技术实现的开源产品。简单说就是一个 PDF 解析器。 最初使用这个东西的原因是公司技术总监说要做一个打印模板设计器。本公司的产品有很多内容都是需要打印的，且每个打印的内容页面设计是不一样的，导致每次实现打印页面的时候就要单独写一个HTML页面，部分还涉及到小票的套打，很繁琐。因此，需要做一个打印设计器，方便每次打印页面的生成，具体我也不知道是怎么弄的。。。后台开发将设计好的内容以buffer的形式传给前端显示，前端这边需要做的就是将buffer内容用PDF显示出来。 下载官网地址 显示 buffer 内容 将viewer.js文件中的变量 DEFAULT_URL 删除 在viewer.html中重新定义DEFAULT_URL,我们在这里做buffer的转换，必须把buffer转换成Uint8Array类型，这样pdf.js才能直接解析。 1234567891011&lt;script&gt; let = &quot;&quot;;//注意，删除的变量在这里重新定义 let PDFData = window.sessionStorage.pdf; let rawLength = PDFData.length; //转换成pdf.js能直接解析的Uint8Array类型,见pdf.js-4068 let array = new Uint8Array(new ArrayBuffer(rawLength)); for(i = 0; i &lt; rawLength; i++) &#123; array[i] = PDFData.charCodeAt(i) &amp; 0xff; &#125; DEFAULT_URL = array;&lt;/script&gt; 这段代码中我将buffer保存在浏览器本地传过来的，因为是在react项目中使用，我没有想到更好的办法将react组件中产生的内容传递到HTML页面中。。。。 以上代码要放在&lt;script src=&quot;viewer.js&quot;&gt;&lt;/script&gt;前面。 至此，内容应该是可以显示了。 直接弹出打印预览窗口前面说过，公司产品有很多内容都是需要打印的，客户不会太愿意在打开PDF预览界面之后手动点击打印按钮去打印，然后弹出打印预览窗口，还要点击打印，从打印机打印出来，这对客户来说打印需要执行的操作付出的代价过大了，所以为了更好的客户体验，在PDF页面渲染完成后直接弹出打印预览界面。 PDF.js重写了浏览器本身的打印方法123//viewer.jsdocument.getElementById(&apos;print&apos;).addEventListener(&apos;click&apos;, SecondaryToolbar.printClick.bind(SecondaryToolbar)); RenderingStates 渲染状态viewer.js 中有RenderingStates来表示渲染的状态123456var RenderingStates = &#123; INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3&#125;; 错误： 首先想到在view.renderingState === RenderingStates.FINISHED的时候执行，即 12345678isViewFinished: function PDFRenderingQueue_isViewFinished(view) &#123; &lt;!-- 添加打印代码 --&gt; if(view.renderingState === RenderingStates.FINISHED &amp;&amp; sessionStorage.isPrint === &apos;true&apos;)&#123; document.getElementById(&apos;print&apos;).click() &#125; &lt;!-- 添加打印代码 end--&gt; return view.renderingState === RenderingStates.FINISHED; &#125; 然后在加载页面多的时候会有这样的提示 嗯==，然后我实在没有找到很合适的地方去调用打印的这个方法，最后在这里加上的 这样以后，‘PDF未完全加载已供打印’的提示没有的，打印页面也正常了。 注意sessionStorage.isPrint=false;这个控制语句要加上，不然即使点击了取消打印预览窗口，该窗口还是会不断弹出来。 如果有更好的方案，请不吝赐教，在下面留言，在下感激不尽。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>PDF.js</tag>
        <tag>javascript</tag>
        <tag>PDF解析器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之操作符]]></title>
    <url>%2FAnastasiaJ%2F2018%2F09%2F06%2FJS%E4%B9%8B%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[记录JS操作符一些重要并容易被忽略的一些用法 与（&amp;&amp;）操作 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值,即第一个操作数为false的时候。 例：123var found = true;var result = (found &amp;&amp; someUndefinedVariable); // 这里会发生错误alert(result); // 这一行不会执行 若开始found为false，则无论第二个操作符是什么，最后都会执行result为false 或（||）操作与逻辑与操作符相似，逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。 例：123var found = true;var result = (found || someUndefinedVariable); // 不会发生错误alert(result); // 会执行（&quot;true&quot;） 加只要有一个是字符串，另一个也默认转成字符串拼接 ‘5’+null= 5null 5+null= 5 5+undefined= NaN 1、有一个是字符串，那么另外一个也会转换为字符串进行拼接。假如一个是字符串，另外一个是null或者undefined，那么相加，null或者undefined就会调用String()方法，获得字符串“null”或者“undefined”，然后进行拼接。 2、假如一个数字加null或者undefined，那么还是把null或者undefined进行Number()转换之后再相加。 3、剩下的原则和其他的差不多，就不多说了。 乘在处理特殊值的情况下，乘法操作符遵循下列特殊的规则： 如果有一个操作数是 NaN，则结果是 NaN； 如果是 Infinity 与 0 相乘，则结果是 NaN； 如果是 Infinity 与非 0 数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号； 如果是 Infinity 与 Infinity 相乘，则结果是 Infinity； 如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。 减将结果转换成数值运算 如果操作数是对象，则调用对象valueOf方法，如果结果是NaN那么结果就是NaN。如果没有valueOf方法，那么调用toString()方法，并将得到的字符串转换为数值。 其他除了加法以外，几乎都是，只要有一个操作数是数值，另一个也默认使用Number()进行数字转换 除规则与乘类似，总之按照正常的运算逻辑来… 有逻辑不通的请一律参考乘的特殊规则 其中： 0/0==NaN 取余、求模 0%0==NaN 关系操作符统一返回true或者false `如果比较的两个数都是字符串，那么会比较字符串对应的字符串编码值。` 几个Number()转化取值： Number(null)==0 Number(undefined)==NaN 总结之前对运算的概念比较模糊，遇到正常的值还好，一旦遇到undefined、null这类特殊的预算就完全懵，其实对于有数字的运算，无外乎几种结果：数值、NaN、Infinity，加法才可能产生字符串的结果。 最后，本文写的过程中也学习了,这篇文章 js操作符类型转换大全（前端面试题之操作符）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+nexT主题+githubPages个人博客搭建]]></title>
    <url>%2FAnastasiaJ%2F2018%2F08%2F29%2Fhexo-nexT%E4%B8%BB%E9%A2%98-githubPages%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[安装 node git hexo-cli npm install -g hexo-cli 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 结构说明 _config.yml 为站点配置文件 scaffolds 为模板文件夹 source 存放用户资源 themes 主题文件夹，里面也会有一个_config.yml，为主题配置文件 NexT主题安装 1git clone https://github.com/theme-next/hexo-theme-next themes/next 这样主题文件就拷贝到themes文件夹中 设置主题 站点配置文件： theme: next 站点文件配置官方配置文档 deploy 部署部分的设置1234deploy:type: gitbranch: 分支名字repo: https://github.com/github用户名/github用户名.github.io.git url配置If your site is put in a subdirectory, set url as ‘http://yoursite.com/child&#39; and root as ‘/child/‘ 12url: https://Anastasia.github.ioroot: /AnastasiaJ/ 本地运行 hexo s --debug 1&lt;div&gt;Syntax Highlighting&lt;/div&gt; 浏览器打开必须是 localhost:4000/你的root 发布到服务器：以上配置好后分别执行12hexo cleanhexo d -g 或者 hexo g -d 最好建一个分支，分支作为发布的博客内容，master作为构建代码，便于多台电脑发布博客 .md文件配置12345678title: hexo+nexT主题+githubPages个人博客搭建date: 2018-08-29 09:41:56categories: "博客搭建" #分类toc: true #是否显示文章目录tags: -nexT -hexo -githubPages 写作 新建文章 hexo new post title (post不定，可以是scaffolds中的任意一篇草稿) 插件 站点访问量“不蒜子” 评论系统1：Valine 评论系统2：必来力LiveRe 音乐：hexo-tag-aplayer 其他插件可参考NexT 使用文档 走过的坑仓库的名字仓库的名字的正确格式是github用户名.github.io hexo s 启动命令不识别需要安装 hexo-server 以上内容写的比较简单，主要是记录了一个主要的搭建过程，具体详细的部分都有官方文档可参考，这里不另外阐述。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>nexT</tag>
        <tag>hexo</tag>
        <tag>githubPages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+NEXT主题个性化配置]]></title>
    <url>%2FAnastasiaJ%2F2018%2F08%2F27%2FHEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[主要说明当前博客中的音乐及其他主题个性化配置 左下角音乐使用插件hexo-tag-aplayer | aplayer npm install hexo-tag-aplayer –save （aplayer） 在themes/next/layout/_custom/header 中加入以下语句，具体的可参考官方文档设置&lt;div id=&quot;player1&quot; class=&quot;aplayer&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://pe5s1kztp.bkt.clouddn.com/css/APlayer.min.css&quot; /&gt; &lt;script src=&quot;http://pe5s1kztp.bkt.clouddn.com/js/APlayer.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; const apo = new APlayer({ container: document.getElementById(&apos;player1&apos;), fixed: true,//固定在左下角 autoplay: false, audio: [{ name: &apos;周杰伦&apos;, artist: &apos;水管的友情&apos;, url: &apos;http://pe5s1kztp.bkt.clouddn.com/music%E6%B0%B4%E7%AE%A1%E7%9A%84%E5%8F%8B%E6%83%85.flac&apos;, cover: &apos;http://pe5s1kztp.bkt.clouddn.com/images/employee-1118183_640.jpg&apos;, }] }); &lt;/script&gt; 其他个性化配置可参考二次元博客 :）]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>nexT</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FAnastasiaJ%2F2018%2F08%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
